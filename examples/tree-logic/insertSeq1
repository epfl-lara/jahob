([|(comment ''Tree.content_def'' ((Tree_content :: obj set) = ({x. (((x::obj) = (null::obj)) | (((Tree_root::obj) ~= (null::obj)) & ((rtrancl_pt :: ((obj => (obj=>bool)) => (obj => (obj=>bool)))) (% (x::obj) (y::obj). (((fieldRead (Node_parent :: (obj=>obj)) x) :: obj) = (y::obj))) x (Tree_root::obj))))} :: obj set)));
(((fieldRead Node_right null) :: obj) = (null::obj));
(((fieldRead Node_left null) :: obj) = (null::obj));
(((fieldRead Node_parent null) :: obj) = (null::obj));
(ALL (xObj::obj). ((xObj::obj) : (Object :: obj set)));
(((Node Int Array) :: obj set) = ({null} :: obj set));
(((Tree Int Array) :: obj set) = ({null} :: obj set));
(((Tree Int Node) :: obj set) = ({null} :: obj set));
((null::obj) : (Object_alloc :: obj set));
((Tree_root::obj) : (Object_alloc :: obj set));
(comment ''field_pointsto'' (pointsto Node Node_right Node));
(comment ''field_pointsto'' (pointsto Node Node_left Node));
(comment ''field_pointsto'' (pointsto Node Node_parent Node));
(comment ''unalloc_lonely'' (ALL (x::obj). (((x::obj) ~: (Object_alloc :: obj set)) --> ((ALL (y::obj). (((fieldRead Node_right y) :: obj) ~= (x::obj))) & (ALL (y::obj). (((fieldRead Node_left y) :: obj) ~= (x::obj))) & (ALL (y::obj). (((fieldRead Node_parent y) :: obj) ~= (x::obj))) & (ALL (z::obj) (i::int). (((arrayRead Array_arrayState z i) :: obj) ~= (x::obj))) & ((Tree_root::obj) ~= (x::obj)) & (((fieldRead Node_right x) :: obj) = (null::obj)) & (((fieldRead Node_left x) :: obj) = (null::obj)) & (((fieldRead Node_parent x) :: obj) = (null::obj)) & (ALL (j::int). (((arrayRead Array_arrayState x j) :: obj) = (null::obj)))))));
(comment ''static_pointsto'' ((Tree_root::obj) : (Node :: obj set)));
(comment ''ProcedurePrecondition'' ((e::obj) ~: (Tree_content :: obj set)));
(comment '': ProcedurePrecondition'' ((ptree :: ((obj=>obj) => (((obj=>obj) list) => bool))) (Node_parent :: (obj=>obj)) [(Node_left :: (obj=>obj)), (Node_right :: (obj=>obj))]));
(comment '': ProcedurePrecondition'' (((fieldRead (Node_parent :: (obj=>obj)) (Tree_root::obj)) :: obj) = (null::obj)));
(comment '': ProcedurePrecondition'' (ALL (x::obj) (y::obj). ((((y::obj) ~= (null::obj)) & (((fieldRead (Node_parent :: (obj=>obj)) x) :: obj) = (y::obj))) --> ((x::obj) : (Tree_content :: obj set)))));
(comment ''e_type'' ((e::obj) : (Node :: obj set)));
(comment ''e_type'' ((e::obj) : (Object_alloc :: obj set)))|] ==>
    (comment ''LoopInvHoldsInitially'' ((null::obj) : (Tree_content :: obj set))))