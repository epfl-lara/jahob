([|(comment ''Tree.content_def'' ((Tree_content :: obj set) = ({x. (((x::obj) = (null::obj)) | (((Tree_root::obj) ~= (null::obj)) & ((rtrancl_pt :: ((obj => (obj=>bool)) => (obj => (obj=>bool)))) (% (x::obj) (y::obj). (((fieldRead (Node_parent :: (obj=>obj)) x) :: obj) = (y::obj))) x (Tree_root::obj))))} :: obj set)));
(((fieldRead Node_right null) :: obj) = (null::obj));
(((fieldRead Node_left null) :: obj) = (null::obj));
(((fieldRead Node_parent null) :: obj) = (null::obj));
(ALL (xObj::obj). ((xObj::obj) : (Object :: obj set)));
(((Node Int Array) :: obj set) = ({null} :: obj set));
(((Tree Int Array) :: obj set) = ({null} :: obj set));
(((Tree Int Node) :: obj set) = ({null} :: obj set));
((null::obj) : (Object_alloc :: obj set));
((Tree_root::obj) : (Object_alloc :: obj set));
(comment ''field_pointsto'' (pointsto Node Node_right Node));
(comment ''field_pointsto'' (pointsto Node Node_left Node));
(comment ''field_pointsto'' (pointsto Node Node_parent Node));
(comment ''unalloc_lonely'' (ALL (x::obj). (((x::obj) ~: (Object_alloc :: obj set)) --> ((ALL (y::obj). (((fieldRead Node_right y) :: obj) ~= (x::obj))) & (ALL (y::obj). (((fieldRead Node_left y) :: obj) ~= (x::obj))) & (ALL (y::obj). (((fieldRead Node_parent y) :: obj) ~= (x::obj))) & (ALL (z::obj) (i::int). (((arrayRead Array_arrayState z i) :: obj) ~= (x::obj))) & ((Tree_root::obj) ~= (x::obj)) & (((fieldRead Node_right x) :: obj) = (null::obj)) & (((fieldRead Node_left x) :: obj) = (null::obj)) & (((fieldRead Node_parent x) :: obj) = (null::obj)) & (ALL (j::int). (((arrayRead Array_arrayState x j) :: obj) = (null::obj)))))));
(comment ''static_pointsto'' ((Tree_root::obj) : (Node :: obj set)));
(comment ''ProcedurePrecondition'' ((e::obj) ~: (Tree_content :: obj set)));
(comment '': ProcedurePrecondition'' ((ptree :: ((obj=>obj) => (((obj=>obj) list) => bool))) (Node_parent :: (obj=>obj)) [(Node_left :: (obj=>obj)), (Node_right :: (obj=>obj))]));
(comment '': ProcedurePrecondition'' (((fieldRead (Node_parent :: (obj=>obj)) (Tree_root::obj)) :: obj) = (null::obj)));
(comment '': ProcedurePrecondition'' (ALL (x::obj) (y::obj). ((((y::obj) ~= (null::obj)) & (((fieldRead (Node_parent :: (obj=>obj)) x) :: obj) = (y::obj))) --> ((x::obj) : (Tree_content :: obj set)))));
(comment ''e_type'' ((e::obj) : (Node :: obj set)));
(comment ''e_type'' ((e::obj) : (Object_alloc :: obj set)));
(comment ''alloc_loop_monotone'' ((Object_alloc :: obj set) \<subseteq> (Object_alloc :: obj set)));
(comment ''tmp_5_alloced_loop'' ((tmp_5_2::obj) : (Object_alloc :: obj set)));
(comment ''tmp_5_alloced_loop'' ((tmp_5_2::obj) : (Node :: obj set)));
(comment ''n_alloced_loop'' ((n_3::obj) : (Object_alloc :: obj set)));
(comment ''n_alloced_loop'' ((n_3::obj) : (Node :: obj set)));
(comment ''tmp_4_alloced_loop'' ((tmp_4_2::obj) : (Object_alloc :: obj set)));
(comment ''tmp_4_alloced_loop'' ((tmp_4_2::obj) : (Node :: obj set)));
(comment ''p_alloced_loop'' ((p_2::obj) : (Object_alloc :: obj set)));
(comment ''p_alloced_loop'' ((p_2::obj) : (Node :: obj set)));
(comment ''AssumingLoopInv'' ((ptree :: ((obj=>obj) => (((obj=>obj) list) => bool))) (Node_parent :: (obj=>obj)) [(Node_left :: (obj=>obj)), (Node_right :: (obj=>obj))]));
(comment ''AssumingLoopInv'' ((((p_2::obj) = (null::obj)) & ((n_3::obj) = (null::obj))) --> ((Tree_root::obj) = (null::obj))));
(comment ''AssumingLoopInv'' ((p_2::obj) : (Tree_content :: obj set)));
(comment ''AssumingLoopInv'' ((n_3::obj) : (Tree_content :: obj set)));
(comment ''AssumingLoopInv'' ((((p_2::obj) ~= (null::obj)) & (wentLeft_3::bool)) --> (((fieldRead (Node_left :: (obj=>obj)) (p_2::obj)) :: obj) = (n_3::obj))));
(comment ''AssumingLoopInv'' ((((p_2::obj) ~= (null::obj)) & (~(wentLeft_3::bool))) --> (((fieldRead (Node_right :: (obj=>obj)) (p_2::obj)) :: obj) = (n_3::obj))));
(comment ''AssumingLoopInv'' ((e::obj) ~= (null::obj)));
(comment ''AssumingLoopInv'' ((e::obj) ~: (Tree_content :: obj set)));
(comment ''LoopConditionFalse'' (~(((n_3::obj) ~= (null::obj)) :: bool)));
(comment ''FalseBranch'' (~(((p_2::obj) = (null::obj)) :: bool)));
(comment ''Tree.content_def'' ((Tree_content_2 :: obj set) = ({x. (((x::obj) = (null::obj)) | (((Tree_root::obj) ~= (null::obj)) & ((rtrancl_pt :: ((obj => (obj=>bool)) => (obj => (obj=>bool)))) (% (x::obj) (y::obj). (((fieldRead ((fieldWrite (Node_parent :: (obj=>obj)) (e::obj) (p_2::obj)) :: (obj=>obj)) x) :: obj) = (y::obj))) x (Tree_root::obj))))} :: obj set)));
(comment ''FalseBranch'' (~(wentLeft_3::bool)))|] ==>
    (comment ''ProcedureEndPostcondition'' ((Tree_content_2 :: obj set) = (((Tree_content :: obj set) Un {(e::obj)}) :: obj set))))